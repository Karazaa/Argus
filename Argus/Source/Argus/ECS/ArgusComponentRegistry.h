// Copyright Karazaa. This is a part of an RTS project called Argus.
// AUTOGENERATED FILE

#pragma once

#include "ArgusECSConstants.h"
#include "ArgusLogging.h"
#include "ArgusMap.h"
#include "ArgusSetAllocator.h"
#include "Containers/BitArray.h"
#include "Containers/Map.h"

// Begin component specific includes.
#include "ComponentDefinitions\AbilityComponent.h"
#include "ComponentDefinitions\ArgusDecalComponent.h"
#include "ComponentDefinitions\AvoidanceGroupingComponent.h"
#include "ComponentDefinitions\CarrierComponent.h"
#include "ComponentDefinitions\CombatComponent.h"
#include "ComponentDefinitions\ConstructionComponent.h"
#include "ComponentDefinitions\FlockingComponent.h"
#include "ComponentDefinitions\FogOfWarLocationComponent.h"
#include "ComponentDefinitions\HealthComponent.h"
#include "ComponentDefinitions\IdentityComponent.h"
#include "ComponentDefinitions\NavigationComponent.h"
#include "ComponentDefinitions\NearbyEntitiesComponent.h"
#include "ComponentDefinitions\NearbyObstaclesComponent.h"
#include "ComponentDefinitions\ObserversComponent.h"
#include "ComponentDefinitions\PassengerComponent.h"
#include "ComponentDefinitions\ResourceComponent.h"
#include "ComponentDefinitions\ResourceExtractionComponent.h"
#include "ComponentDefinitions\SpawningComponent.h"
#include "ComponentDefinitions\TargetingComponent.h"
#include "ComponentDefinitions\TaskComponent.h"
#include "ComponentDefinitions\TimerComponent.h"
#include "ComponentDefinitions\TransformComponent.h"
#include "ComponentDefinitions\VelocityComponent.h"

// Begin dynamically allocated component specific includes.
#include "DynamicAllocComponentDefinitions\AssetLoadingComponent.h"
#include "DynamicAllocComponentDefinitions\FogOfWarComponent.h"
#include "DynamicAllocComponentDefinitions\InputInterfaceComponent.h"
#include "DynamicAllocComponentDefinitions\ReticleComponent.h"
#include "DynamicAllocComponentDefinitions\SpatialPartitioningComponent.h"
#include "DynamicAllocComponentDefinitions\TeamCommanderComponent.h"

class ArgusComponentRegistry
{
public:
	template<typename ArgusComponent>
	static ArgusComponent* GetComponent(uint16 entityId)
	{
		return nullptr;
	}

	template<typename ArgusComponent>
	static ArgusComponent* AddComponent(uint16 entityId)
	{
		return nullptr;
	}

	template<typename ArgusComponent>
	static ArgusComponent* GetOrAddComponent(uint16 entityId)
	{
		return nullptr;
	}

	static void RemoveComponentsForEntity(uint16 entityId);
	static void FlushAllComponents();
	static uint16 GetOwningEntityIdForComponentMember(const void* memberAddress);

	static void AppendComponentDebugStrings(uint16 entityId, FString& debugStringToAppendTo);

#if !UE_BUILD_SHIPPING
	static void DrawComponentsDebug(uint16 entityId);
#endif //!UE_BUILD_SHIPPING

	static constexpr uint32 k_numComponentTypes = 29;

	// Begin component specific template specifiers.
	
#pragma region AbilityComponent
private:
	static AbilityComponent* s_AbilityComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isAbilityComponentActive;
public:
	template<>
	inline AbilityComponent* GetComponent<AbilityComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_AbilityComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(AbilityComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isAbilityComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isAbilityComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_AbilityComponents[entityId];
	}

	template<>
	inline AbilityComponent* AddComponent<AbilityComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_AbilityComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(AbilityComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isAbilityComponentActive.Num() == 0))
		{
			s_isAbilityComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isAbilityComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(AbilityComponent), entityId);
			return &s_AbilityComponents[entityId];
		}

		s_isAbilityComponentActive[entityId] = true;
		s_AbilityComponents[entityId].Reset();
		return &s_AbilityComponents[entityId];
	}

	template<>
	inline AbilityComponent* GetOrAddComponent<AbilityComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_AbilityComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(AbilityComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isAbilityComponentActive.Num() == 0))
		{
			s_isAbilityComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isAbilityComponentActive[entityId])
		{
			return &s_AbilityComponents[entityId];
		}
		else
		{
			s_isAbilityComponentActive[entityId] = true;
			s_AbilityComponents[entityId].Reset();
			return &s_AbilityComponents[entityId];
		}
	}

	friend struct AbilityComponent;
#pragma endregion
#pragma region ArgusDecalComponent
private:
	static ArgusDecalComponent* s_ArgusDecalComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isArgusDecalComponentActive;
public:
	template<>
	inline ArgusDecalComponent* GetComponent<ArgusDecalComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ArgusDecalComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ArgusDecalComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isArgusDecalComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isArgusDecalComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_ArgusDecalComponents[entityId];
	}

	template<>
	inline ArgusDecalComponent* AddComponent<ArgusDecalComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ArgusDecalComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ArgusDecalComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isArgusDecalComponentActive.Num() == 0))
		{
			s_isArgusDecalComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isArgusDecalComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(ArgusDecalComponent), entityId);
			return &s_ArgusDecalComponents[entityId];
		}

		s_isArgusDecalComponentActive[entityId] = true;
		s_ArgusDecalComponents[entityId].Reset();
		return &s_ArgusDecalComponents[entityId];
	}

	template<>
	inline ArgusDecalComponent* GetOrAddComponent<ArgusDecalComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ArgusDecalComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ArgusDecalComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isArgusDecalComponentActive.Num() == 0))
		{
			s_isArgusDecalComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isArgusDecalComponentActive[entityId])
		{
			return &s_ArgusDecalComponents[entityId];
		}
		else
		{
			s_isArgusDecalComponentActive[entityId] = true;
			s_ArgusDecalComponents[entityId].Reset();
			return &s_ArgusDecalComponents[entityId];
		}
	}

	friend struct ArgusDecalComponent;
#pragma endregion
#pragma region AvoidanceGroupingComponent
private:
	static AvoidanceGroupingComponent* s_AvoidanceGroupingComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isAvoidanceGroupingComponentActive;
public:
	template<>
	inline AvoidanceGroupingComponent* GetComponent<AvoidanceGroupingComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_AvoidanceGroupingComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(AvoidanceGroupingComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isAvoidanceGroupingComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isAvoidanceGroupingComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_AvoidanceGroupingComponents[entityId];
	}

	template<>
	inline AvoidanceGroupingComponent* AddComponent<AvoidanceGroupingComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_AvoidanceGroupingComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(AvoidanceGroupingComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isAvoidanceGroupingComponentActive.Num() == 0))
		{
			s_isAvoidanceGroupingComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isAvoidanceGroupingComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(AvoidanceGroupingComponent), entityId);
			return &s_AvoidanceGroupingComponents[entityId];
		}

		s_isAvoidanceGroupingComponentActive[entityId] = true;
		s_AvoidanceGroupingComponents[entityId].Reset();
		return &s_AvoidanceGroupingComponents[entityId];
	}

	template<>
	inline AvoidanceGroupingComponent* GetOrAddComponent<AvoidanceGroupingComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_AvoidanceGroupingComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(AvoidanceGroupingComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isAvoidanceGroupingComponentActive.Num() == 0))
		{
			s_isAvoidanceGroupingComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isAvoidanceGroupingComponentActive[entityId])
		{
			return &s_AvoidanceGroupingComponents[entityId];
		}
		else
		{
			s_isAvoidanceGroupingComponentActive[entityId] = true;
			s_AvoidanceGroupingComponents[entityId].Reset();
			return &s_AvoidanceGroupingComponents[entityId];
		}
	}

	friend struct AvoidanceGroupingComponent;
#pragma endregion
#pragma region CarrierComponent
private:
	static CarrierComponent* s_CarrierComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isCarrierComponentActive;
public:
	template<>
	inline CarrierComponent* GetComponent<CarrierComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_CarrierComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(CarrierComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isCarrierComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isCarrierComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_CarrierComponents[entityId];
	}

	template<>
	inline CarrierComponent* AddComponent<CarrierComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_CarrierComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(CarrierComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isCarrierComponentActive.Num() == 0))
		{
			s_isCarrierComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isCarrierComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(CarrierComponent), entityId);
			return &s_CarrierComponents[entityId];
		}

		s_isCarrierComponentActive[entityId] = true;
		s_CarrierComponents[entityId].Reset();
		return &s_CarrierComponents[entityId];
	}

	template<>
	inline CarrierComponent* GetOrAddComponent<CarrierComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_CarrierComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(CarrierComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isCarrierComponentActive.Num() == 0))
		{
			s_isCarrierComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isCarrierComponentActive[entityId])
		{
			return &s_CarrierComponents[entityId];
		}
		else
		{
			s_isCarrierComponentActive[entityId] = true;
			s_CarrierComponents[entityId].Reset();
			return &s_CarrierComponents[entityId];
		}
	}

	friend struct CarrierComponent;
#pragma endregion
#pragma region CombatComponent
private:
	static CombatComponent* s_CombatComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isCombatComponentActive;
public:
	template<>
	inline CombatComponent* GetComponent<CombatComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_CombatComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(CombatComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isCombatComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isCombatComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_CombatComponents[entityId];
	}

	template<>
	inline CombatComponent* AddComponent<CombatComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_CombatComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(CombatComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isCombatComponentActive.Num() == 0))
		{
			s_isCombatComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isCombatComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(CombatComponent), entityId);
			return &s_CombatComponents[entityId];
		}

		s_isCombatComponentActive[entityId] = true;
		s_CombatComponents[entityId].Reset();
		return &s_CombatComponents[entityId];
	}

	template<>
	inline CombatComponent* GetOrAddComponent<CombatComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_CombatComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(CombatComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isCombatComponentActive.Num() == 0))
		{
			s_isCombatComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isCombatComponentActive[entityId])
		{
			return &s_CombatComponents[entityId];
		}
		else
		{
			s_isCombatComponentActive[entityId] = true;
			s_CombatComponents[entityId].Reset();
			return &s_CombatComponents[entityId];
		}
	}

	friend struct CombatComponent;
#pragma endregion
#pragma region ConstructionComponent
private:
	static ConstructionComponent* s_ConstructionComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isConstructionComponentActive;
public:
	template<>
	inline ConstructionComponent* GetComponent<ConstructionComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ConstructionComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ConstructionComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isConstructionComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isConstructionComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_ConstructionComponents[entityId];
	}

	template<>
	inline ConstructionComponent* AddComponent<ConstructionComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ConstructionComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ConstructionComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isConstructionComponentActive.Num() == 0))
		{
			s_isConstructionComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isConstructionComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(ConstructionComponent), entityId);
			return &s_ConstructionComponents[entityId];
		}

		s_isConstructionComponentActive[entityId] = true;
		s_ConstructionComponents[entityId].Reset();
		return &s_ConstructionComponents[entityId];
	}

	template<>
	inline ConstructionComponent* GetOrAddComponent<ConstructionComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ConstructionComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ConstructionComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isConstructionComponentActive.Num() == 0))
		{
			s_isConstructionComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isConstructionComponentActive[entityId])
		{
			return &s_ConstructionComponents[entityId];
		}
		else
		{
			s_isConstructionComponentActive[entityId] = true;
			s_ConstructionComponents[entityId].Reset();
			return &s_ConstructionComponents[entityId];
		}
	}

	friend struct ConstructionComponent;
#pragma endregion
#pragma region FlockingComponent
private:
	static FlockingComponent* s_FlockingComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isFlockingComponentActive;
public:
	template<>
	inline FlockingComponent* GetComponent<FlockingComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_FlockingComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(FlockingComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isFlockingComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isFlockingComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_FlockingComponents[entityId];
	}

	template<>
	inline FlockingComponent* AddComponent<FlockingComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_FlockingComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(FlockingComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isFlockingComponentActive.Num() == 0))
		{
			s_isFlockingComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isFlockingComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(FlockingComponent), entityId);
			return &s_FlockingComponents[entityId];
		}

		s_isFlockingComponentActive[entityId] = true;
		s_FlockingComponents[entityId].Reset();
		return &s_FlockingComponents[entityId];
	}

	template<>
	inline FlockingComponent* GetOrAddComponent<FlockingComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_FlockingComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(FlockingComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isFlockingComponentActive.Num() == 0))
		{
			s_isFlockingComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isFlockingComponentActive[entityId])
		{
			return &s_FlockingComponents[entityId];
		}
		else
		{
			s_isFlockingComponentActive[entityId] = true;
			s_FlockingComponents[entityId].Reset();
			return &s_FlockingComponents[entityId];
		}
	}

	friend struct FlockingComponent;
#pragma endregion
#pragma region FogOfWarLocationComponent
private:
	static FogOfWarLocationComponent* s_FogOfWarLocationComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isFogOfWarLocationComponentActive;
public:
	template<>
	inline FogOfWarLocationComponent* GetComponent<FogOfWarLocationComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_FogOfWarLocationComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(FogOfWarLocationComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isFogOfWarLocationComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isFogOfWarLocationComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_FogOfWarLocationComponents[entityId];
	}

	template<>
	inline FogOfWarLocationComponent* AddComponent<FogOfWarLocationComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_FogOfWarLocationComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(FogOfWarLocationComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isFogOfWarLocationComponentActive.Num() == 0))
		{
			s_isFogOfWarLocationComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isFogOfWarLocationComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(FogOfWarLocationComponent), entityId);
			return &s_FogOfWarLocationComponents[entityId];
		}

		s_isFogOfWarLocationComponentActive[entityId] = true;
		s_FogOfWarLocationComponents[entityId].Reset();
		return &s_FogOfWarLocationComponents[entityId];
	}

	template<>
	inline FogOfWarLocationComponent* GetOrAddComponent<FogOfWarLocationComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_FogOfWarLocationComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(FogOfWarLocationComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isFogOfWarLocationComponentActive.Num() == 0))
		{
			s_isFogOfWarLocationComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isFogOfWarLocationComponentActive[entityId])
		{
			return &s_FogOfWarLocationComponents[entityId];
		}
		else
		{
			s_isFogOfWarLocationComponentActive[entityId] = true;
			s_FogOfWarLocationComponents[entityId].Reset();
			return &s_FogOfWarLocationComponents[entityId];
		}
	}

	friend struct FogOfWarLocationComponent;
#pragma endregion
#pragma region HealthComponent
private:
	static HealthComponent* s_HealthComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isHealthComponentActive;
public:
	template<>
	inline HealthComponent* GetComponent<HealthComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_HealthComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(HealthComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isHealthComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isHealthComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_HealthComponents[entityId];
	}

	template<>
	inline HealthComponent* AddComponent<HealthComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_HealthComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(HealthComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isHealthComponentActive.Num() == 0))
		{
			s_isHealthComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isHealthComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(HealthComponent), entityId);
			return &s_HealthComponents[entityId];
		}

		s_isHealthComponentActive[entityId] = true;
		s_HealthComponents[entityId].Reset();
		return &s_HealthComponents[entityId];
	}

	template<>
	inline HealthComponent* GetOrAddComponent<HealthComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_HealthComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(HealthComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isHealthComponentActive.Num() == 0))
		{
			s_isHealthComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isHealthComponentActive[entityId])
		{
			return &s_HealthComponents[entityId];
		}
		else
		{
			s_isHealthComponentActive[entityId] = true;
			s_HealthComponents[entityId].Reset();
			return &s_HealthComponents[entityId];
		}
	}

	friend struct HealthComponent;
#pragma endregion
#pragma region IdentityComponent
private:
	static IdentityComponent* s_IdentityComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isIdentityComponentActive;
public:
	template<>
	inline IdentityComponent* GetComponent<IdentityComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_IdentityComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(IdentityComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isIdentityComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isIdentityComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_IdentityComponents[entityId];
	}

	template<>
	inline IdentityComponent* AddComponent<IdentityComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_IdentityComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(IdentityComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isIdentityComponentActive.Num() == 0))
		{
			s_isIdentityComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isIdentityComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(IdentityComponent), entityId);
			return &s_IdentityComponents[entityId];
		}

		s_isIdentityComponentActive[entityId] = true;
		s_IdentityComponents[entityId].Reset();
		return &s_IdentityComponents[entityId];
	}

	template<>
	inline IdentityComponent* GetOrAddComponent<IdentityComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_IdentityComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(IdentityComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isIdentityComponentActive.Num() == 0))
		{
			s_isIdentityComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isIdentityComponentActive[entityId])
		{
			return &s_IdentityComponents[entityId];
		}
		else
		{
			s_isIdentityComponentActive[entityId] = true;
			s_IdentityComponents[entityId].Reset();
			return &s_IdentityComponents[entityId];
		}
	}

	friend struct IdentityComponent;
#pragma endregion
#pragma region NavigationComponent
private:
	static NavigationComponent* s_NavigationComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isNavigationComponentActive;
public:
	template<>
	inline NavigationComponent* GetComponent<NavigationComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_NavigationComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(NavigationComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isNavigationComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isNavigationComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_NavigationComponents[entityId];
	}

	template<>
	inline NavigationComponent* AddComponent<NavigationComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_NavigationComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(NavigationComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isNavigationComponentActive.Num() == 0))
		{
			s_isNavigationComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isNavigationComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(NavigationComponent), entityId);
			return &s_NavigationComponents[entityId];
		}

		s_isNavigationComponentActive[entityId] = true;
		s_NavigationComponents[entityId].Reset();
		return &s_NavigationComponents[entityId];
	}

	template<>
	inline NavigationComponent* GetOrAddComponent<NavigationComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_NavigationComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(NavigationComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isNavigationComponentActive.Num() == 0))
		{
			s_isNavigationComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isNavigationComponentActive[entityId])
		{
			return &s_NavigationComponents[entityId];
		}
		else
		{
			s_isNavigationComponentActive[entityId] = true;
			s_NavigationComponents[entityId].Reset();
			return &s_NavigationComponents[entityId];
		}
	}

	friend struct NavigationComponent;
#pragma endregion
#pragma region NearbyEntitiesComponent
private:
	static NearbyEntitiesComponent* s_NearbyEntitiesComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isNearbyEntitiesComponentActive;
public:
	template<>
	inline NearbyEntitiesComponent* GetComponent<NearbyEntitiesComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_NearbyEntitiesComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(NearbyEntitiesComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isNearbyEntitiesComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isNearbyEntitiesComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_NearbyEntitiesComponents[entityId];
	}

	template<>
	inline NearbyEntitiesComponent* AddComponent<NearbyEntitiesComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_NearbyEntitiesComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(NearbyEntitiesComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isNearbyEntitiesComponentActive.Num() == 0))
		{
			s_isNearbyEntitiesComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isNearbyEntitiesComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(NearbyEntitiesComponent), entityId);
			return &s_NearbyEntitiesComponents[entityId];
		}

		s_isNearbyEntitiesComponentActive[entityId] = true;
		s_NearbyEntitiesComponents[entityId].Reset();
		return &s_NearbyEntitiesComponents[entityId];
	}

	template<>
	inline NearbyEntitiesComponent* GetOrAddComponent<NearbyEntitiesComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_NearbyEntitiesComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(NearbyEntitiesComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isNearbyEntitiesComponentActive.Num() == 0))
		{
			s_isNearbyEntitiesComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isNearbyEntitiesComponentActive[entityId])
		{
			return &s_NearbyEntitiesComponents[entityId];
		}
		else
		{
			s_isNearbyEntitiesComponentActive[entityId] = true;
			s_NearbyEntitiesComponents[entityId].Reset();
			return &s_NearbyEntitiesComponents[entityId];
		}
	}

	friend struct NearbyEntitiesComponent;
#pragma endregion
#pragma region NearbyObstaclesComponent
private:
	static NearbyObstaclesComponent* s_NearbyObstaclesComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isNearbyObstaclesComponentActive;
public:
	template<>
	inline NearbyObstaclesComponent* GetComponent<NearbyObstaclesComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_NearbyObstaclesComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(NearbyObstaclesComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isNearbyObstaclesComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isNearbyObstaclesComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_NearbyObstaclesComponents[entityId];
	}

	template<>
	inline NearbyObstaclesComponent* AddComponent<NearbyObstaclesComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_NearbyObstaclesComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(NearbyObstaclesComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isNearbyObstaclesComponentActive.Num() == 0))
		{
			s_isNearbyObstaclesComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isNearbyObstaclesComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(NearbyObstaclesComponent), entityId);
			return &s_NearbyObstaclesComponents[entityId];
		}

		s_isNearbyObstaclesComponentActive[entityId] = true;
		s_NearbyObstaclesComponents[entityId].Reset();
		return &s_NearbyObstaclesComponents[entityId];
	}

	template<>
	inline NearbyObstaclesComponent* GetOrAddComponent<NearbyObstaclesComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_NearbyObstaclesComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(NearbyObstaclesComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isNearbyObstaclesComponentActive.Num() == 0))
		{
			s_isNearbyObstaclesComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isNearbyObstaclesComponentActive[entityId])
		{
			return &s_NearbyObstaclesComponents[entityId];
		}
		else
		{
			s_isNearbyObstaclesComponentActive[entityId] = true;
			s_NearbyObstaclesComponents[entityId].Reset();
			return &s_NearbyObstaclesComponents[entityId];
		}
	}

	friend struct NearbyObstaclesComponent;
#pragma endregion
#pragma region ObserversComponent
private:
	static ObserversComponent* s_ObserversComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isObserversComponentActive;
public:
	template<>
	inline ObserversComponent* GetComponent<ObserversComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ObserversComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ObserversComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isObserversComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isObserversComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_ObserversComponents[entityId];
	}

	template<>
	inline ObserversComponent* AddComponent<ObserversComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ObserversComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ObserversComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isObserversComponentActive.Num() == 0))
		{
			s_isObserversComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isObserversComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(ObserversComponent), entityId);
			return &s_ObserversComponents[entityId];
		}

		s_isObserversComponentActive[entityId] = true;
		s_ObserversComponents[entityId].Reset();
		return &s_ObserversComponents[entityId];
	}

	template<>
	inline ObserversComponent* GetOrAddComponent<ObserversComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ObserversComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ObserversComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isObserversComponentActive.Num() == 0))
		{
			s_isObserversComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isObserversComponentActive[entityId])
		{
			return &s_ObserversComponents[entityId];
		}
		else
		{
			s_isObserversComponentActive[entityId] = true;
			s_ObserversComponents[entityId].Reset();
			return &s_ObserversComponents[entityId];
		}
	}

	friend struct ObserversComponent;
#pragma endregion
#pragma region PassengerComponent
private:
	static PassengerComponent* s_PassengerComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isPassengerComponentActive;
public:
	template<>
	inline PassengerComponent* GetComponent<PassengerComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_PassengerComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(PassengerComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isPassengerComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isPassengerComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_PassengerComponents[entityId];
	}

	template<>
	inline PassengerComponent* AddComponent<PassengerComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_PassengerComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(PassengerComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isPassengerComponentActive.Num() == 0))
		{
			s_isPassengerComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isPassengerComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(PassengerComponent), entityId);
			return &s_PassengerComponents[entityId];
		}

		s_isPassengerComponentActive[entityId] = true;
		s_PassengerComponents[entityId].Reset();
		return &s_PassengerComponents[entityId];
	}

	template<>
	inline PassengerComponent* GetOrAddComponent<PassengerComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_PassengerComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(PassengerComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isPassengerComponentActive.Num() == 0))
		{
			s_isPassengerComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isPassengerComponentActive[entityId])
		{
			return &s_PassengerComponents[entityId];
		}
		else
		{
			s_isPassengerComponentActive[entityId] = true;
			s_PassengerComponents[entityId].Reset();
			return &s_PassengerComponents[entityId];
		}
	}

	friend struct PassengerComponent;
#pragma endregion
#pragma region ResourceComponent
private:
	static ResourceComponent* s_ResourceComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isResourceComponentActive;
public:
	template<>
	inline ResourceComponent* GetComponent<ResourceComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ResourceComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ResourceComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isResourceComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isResourceComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_ResourceComponents[entityId];
	}

	template<>
	inline ResourceComponent* AddComponent<ResourceComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ResourceComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ResourceComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isResourceComponentActive.Num() == 0))
		{
			s_isResourceComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isResourceComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(ResourceComponent), entityId);
			return &s_ResourceComponents[entityId];
		}

		s_isResourceComponentActive[entityId] = true;
		s_ResourceComponents[entityId].Reset();
		return &s_ResourceComponents[entityId];
	}

	template<>
	inline ResourceComponent* GetOrAddComponent<ResourceComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ResourceComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ResourceComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isResourceComponentActive.Num() == 0))
		{
			s_isResourceComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isResourceComponentActive[entityId])
		{
			return &s_ResourceComponents[entityId];
		}
		else
		{
			s_isResourceComponentActive[entityId] = true;
			s_ResourceComponents[entityId].Reset();
			return &s_ResourceComponents[entityId];
		}
	}

	friend struct ResourceComponent;
#pragma endregion
#pragma region ResourceExtractionComponent
private:
	static ResourceExtractionComponent* s_ResourceExtractionComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isResourceExtractionComponentActive;
public:
	template<>
	inline ResourceExtractionComponent* GetComponent<ResourceExtractionComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ResourceExtractionComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ResourceExtractionComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isResourceExtractionComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isResourceExtractionComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_ResourceExtractionComponents[entityId];
	}

	template<>
	inline ResourceExtractionComponent* AddComponent<ResourceExtractionComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ResourceExtractionComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ResourceExtractionComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isResourceExtractionComponentActive.Num() == 0))
		{
			s_isResourceExtractionComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isResourceExtractionComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(ResourceExtractionComponent), entityId);
			return &s_ResourceExtractionComponents[entityId];
		}

		s_isResourceExtractionComponentActive[entityId] = true;
		s_ResourceExtractionComponents[entityId].Reset();
		return &s_ResourceExtractionComponents[entityId];
	}

	template<>
	inline ResourceExtractionComponent* GetOrAddComponent<ResourceExtractionComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_ResourceExtractionComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ResourceExtractionComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isResourceExtractionComponentActive.Num() == 0))
		{
			s_isResourceExtractionComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isResourceExtractionComponentActive[entityId])
		{
			return &s_ResourceExtractionComponents[entityId];
		}
		else
		{
			s_isResourceExtractionComponentActive[entityId] = true;
			s_ResourceExtractionComponents[entityId].Reset();
			return &s_ResourceExtractionComponents[entityId];
		}
	}

	friend struct ResourceExtractionComponent;
#pragma endregion
#pragma region SpawningComponent
private:
	static SpawningComponent* s_SpawningComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isSpawningComponentActive;
public:
	template<>
	inline SpawningComponent* GetComponent<SpawningComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_SpawningComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(SpawningComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isSpawningComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isSpawningComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_SpawningComponents[entityId];
	}

	template<>
	inline SpawningComponent* AddComponent<SpawningComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_SpawningComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(SpawningComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isSpawningComponentActive.Num() == 0))
		{
			s_isSpawningComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isSpawningComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(SpawningComponent), entityId);
			return &s_SpawningComponents[entityId];
		}

		s_isSpawningComponentActive[entityId] = true;
		s_SpawningComponents[entityId].Reset();
		return &s_SpawningComponents[entityId];
	}

	template<>
	inline SpawningComponent* GetOrAddComponent<SpawningComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_SpawningComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(SpawningComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isSpawningComponentActive.Num() == 0))
		{
			s_isSpawningComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isSpawningComponentActive[entityId])
		{
			return &s_SpawningComponents[entityId];
		}
		else
		{
			s_isSpawningComponentActive[entityId] = true;
			s_SpawningComponents[entityId].Reset();
			return &s_SpawningComponents[entityId];
		}
	}

	friend struct SpawningComponent;
#pragma endregion
#pragma region TargetingComponent
private:
	static TargetingComponent* s_TargetingComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isTargetingComponentActive;
public:
	template<>
	inline TargetingComponent* GetComponent<TargetingComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TargetingComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TargetingComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTargetingComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isTargetingComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_TargetingComponents[entityId];
	}

	template<>
	inline TargetingComponent* AddComponent<TargetingComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TargetingComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TargetingComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTargetingComponentActive.Num() == 0))
		{
			s_isTargetingComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isTargetingComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(TargetingComponent), entityId);
			return &s_TargetingComponents[entityId];
		}

		s_isTargetingComponentActive[entityId] = true;
		s_TargetingComponents[entityId].Reset();
		return &s_TargetingComponents[entityId];
	}

	template<>
	inline TargetingComponent* GetOrAddComponent<TargetingComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TargetingComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TargetingComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTargetingComponentActive.Num() == 0))
		{
			s_isTargetingComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isTargetingComponentActive[entityId])
		{
			return &s_TargetingComponents[entityId];
		}
		else
		{
			s_isTargetingComponentActive[entityId] = true;
			s_TargetingComponents[entityId].Reset();
			return &s_TargetingComponents[entityId];
		}
	}

	friend struct TargetingComponent;
#pragma endregion
#pragma region TaskComponent
private:
	static TaskComponent* s_TaskComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isTaskComponentActive;
public:
	template<>
	inline TaskComponent* GetComponent<TaskComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TaskComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TaskComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTaskComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isTaskComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_TaskComponents[entityId];
	}

	template<>
	inline TaskComponent* AddComponent<TaskComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TaskComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TaskComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTaskComponentActive.Num() == 0))
		{
			s_isTaskComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isTaskComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(TaskComponent), entityId);
			return &s_TaskComponents[entityId];
		}

		s_isTaskComponentActive[entityId] = true;
		s_TaskComponents[entityId].Reset();
		return &s_TaskComponents[entityId];
	}

	template<>
	inline TaskComponent* GetOrAddComponent<TaskComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TaskComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TaskComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTaskComponentActive.Num() == 0))
		{
			s_isTaskComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isTaskComponentActive[entityId])
		{
			return &s_TaskComponents[entityId];
		}
		else
		{
			s_isTaskComponentActive[entityId] = true;
			s_TaskComponents[entityId].Reset();
			return &s_TaskComponents[entityId];
		}
	}

	friend struct TaskComponent;
#pragma endregion
#pragma region TimerComponent
private:
	static TimerComponent* s_TimerComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isTimerComponentActive;
public:
	template<>
	inline TimerComponent* GetComponent<TimerComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TimerComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TimerComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTimerComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isTimerComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_TimerComponents[entityId];
	}

	template<>
	inline TimerComponent* AddComponent<TimerComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TimerComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TimerComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTimerComponentActive.Num() == 0))
		{
			s_isTimerComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isTimerComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(TimerComponent), entityId);
			return &s_TimerComponents[entityId];
		}

		s_isTimerComponentActive[entityId] = true;
		s_TimerComponents[entityId].Reset();
		return &s_TimerComponents[entityId];
	}

	template<>
	inline TimerComponent* GetOrAddComponent<TimerComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TimerComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TimerComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTimerComponentActive.Num() == 0))
		{
			s_isTimerComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isTimerComponentActive[entityId])
		{
			return &s_TimerComponents[entityId];
		}
		else
		{
			s_isTimerComponentActive[entityId] = true;
			s_TimerComponents[entityId].Reset();
			return &s_TimerComponents[entityId];
		}
	}

	friend struct TimerComponent;
#pragma endregion
#pragma region TransformComponent
private:
	static TransformComponent* s_TransformComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isTransformComponentActive;
public:
	template<>
	inline TransformComponent* GetComponent<TransformComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TransformComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TransformComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTransformComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isTransformComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_TransformComponents[entityId];
	}

	template<>
	inline TransformComponent* AddComponent<TransformComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TransformComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TransformComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTransformComponentActive.Num() == 0))
		{
			s_isTransformComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isTransformComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(TransformComponent), entityId);
			return &s_TransformComponents[entityId];
		}

		s_isTransformComponentActive[entityId] = true;
		s_TransformComponents[entityId].Reset();
		return &s_TransformComponents[entityId];
	}

	template<>
	inline TransformComponent* GetOrAddComponent<TransformComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_TransformComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TransformComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isTransformComponentActive.Num() == 0))
		{
			s_isTransformComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isTransformComponentActive[entityId])
		{
			return &s_TransformComponents[entityId];
		}
		else
		{
			s_isTransformComponentActive[entityId] = true;
			s_TransformComponents[entityId].Reset();
			return &s_TransformComponents[entityId];
		}
	}

	friend struct TransformComponent;
#pragma endregion
#pragma region VelocityComponent
private:
	static VelocityComponent* s_VelocityComponents;
	static TBitArray<ArgusContainerAllocator<ArgusECSConstants::k_numBitBuckets> > s_isVelocityComponentActive;
public:
	template<>
	inline VelocityComponent* GetComponent<VelocityComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_VelocityComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(VelocityComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isVelocityComponentActive.Num() == 0))
		{
			return nullptr;
		}

		if (!s_isVelocityComponentActive[entityId])
		{
			return nullptr;
		}

		return &s_VelocityComponents[entityId];
	}

	template<>
	inline VelocityComponent* AddComponent<VelocityComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_VelocityComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(VelocityComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isVelocityComponentActive.Num() == 0))
		{
			s_isVelocityComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (UNLIKELY(s_isVelocityComponentActive[entityId]))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(VelocityComponent), entityId);
			return &s_VelocityComponents[entityId];
		}

		s_isVelocityComponentActive[entityId] = true;
		s_VelocityComponents[entityId].Reset();
		return &s_VelocityComponents[entityId];
	}

	template<>
	inline VelocityComponent* GetOrAddComponent<VelocityComponent>(uint16 entityId)
	{
		if (UNLIKELY(!s_VelocityComponents))
		{
			return nullptr;
		}

		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(VelocityComponent));
			return nullptr;
		}

		if (UNLIKELY(s_isVelocityComponentActive.Num() == 0))
		{
			s_isVelocityComponentActive.SetNum(ArgusECSConstants::k_maxEntities, false);
		}

		if (s_isVelocityComponentActive[entityId])
		{
			return &s_VelocityComponents[entityId];
		}
		else
		{
			s_isVelocityComponentActive[entityId] = true;
			s_VelocityComponents[entityId].Reset();
			return &s_VelocityComponents[entityId];
		}
	}

	friend struct VelocityComponent;
#pragma endregion
	
	// Begin dynamically allocated component specific template specifiers.

#pragma region AssetLoadingComponent
private:
	static ArgusMap<uint16, AssetLoadingComponent*, ArgusSetAllocator<1> > s_AssetLoadingComponents;
public:
	template<>
	inline AssetLoadingComponent* GetComponent<AssetLoadingComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(AssetLoadingComponent));
			return nullptr;
		}

		if (!s_AssetLoadingComponents.Contains(entityId))
		{
			return nullptr;
		}

		return s_AssetLoadingComponents[entityId];
	}

	template<>
	inline AssetLoadingComponent* AddComponent<AssetLoadingComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(AssetLoadingComponent));
			return nullptr;
		}

		if (UNLIKELY(s_AssetLoadingComponents.Contains(entityId)))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(AssetLoadingComponent), entityId);
			return s_AssetLoadingComponents[entityId];
		}

		AssetLoadingComponent* output = new (ArgusMemorySource::Allocate<AssetLoadingComponent>()) AssetLoadingComponent();
		s_AssetLoadingComponents.Emplace(entityId, output);
		return output;
	}

	template<>
	inline AssetLoadingComponent* GetOrAddComponent<AssetLoadingComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(AssetLoadingComponent));
			return nullptr;
		}

		if (!s_AssetLoadingComponents.Contains(entityId))
		{
			AssetLoadingComponent* output = new (ArgusMemorySource::Allocate<AssetLoadingComponent>()) AssetLoadingComponent();
			s_AssetLoadingComponents.Emplace(entityId, output);
			return output;
		}

		return s_AssetLoadingComponents[entityId];
	}
#pragma endregion
#pragma region FogOfWarComponent
private:
	static ArgusMap<uint16, FogOfWarComponent*, ArgusSetAllocator<1> > s_FogOfWarComponents;
public:
	template<>
	inline FogOfWarComponent* GetComponent<FogOfWarComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(FogOfWarComponent));
			return nullptr;
		}

		if (!s_FogOfWarComponents.Contains(entityId))
		{
			return nullptr;
		}

		return s_FogOfWarComponents[entityId];
	}

	template<>
	inline FogOfWarComponent* AddComponent<FogOfWarComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(FogOfWarComponent));
			return nullptr;
		}

		if (UNLIKELY(s_FogOfWarComponents.Contains(entityId)))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(FogOfWarComponent), entityId);
			return s_FogOfWarComponents[entityId];
		}

		FogOfWarComponent* output = new (ArgusMemorySource::Allocate<FogOfWarComponent>()) FogOfWarComponent();
		s_FogOfWarComponents.Emplace(entityId, output);
		return output;
	}

	template<>
	inline FogOfWarComponent* GetOrAddComponent<FogOfWarComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(FogOfWarComponent));
			return nullptr;
		}

		if (!s_FogOfWarComponents.Contains(entityId))
		{
			FogOfWarComponent* output = new (ArgusMemorySource::Allocate<FogOfWarComponent>()) FogOfWarComponent();
			s_FogOfWarComponents.Emplace(entityId, output);
			return output;
		}

		return s_FogOfWarComponents[entityId];
	}
#pragma endregion
#pragma region InputInterfaceComponent
private:
	static ArgusMap<uint16, InputInterfaceComponent*, ArgusSetAllocator<1> > s_InputInterfaceComponents;
public:
	template<>
	inline InputInterfaceComponent* GetComponent<InputInterfaceComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(InputInterfaceComponent));
			return nullptr;
		}

		if (!s_InputInterfaceComponents.Contains(entityId))
		{
			return nullptr;
		}

		return s_InputInterfaceComponents[entityId];
	}

	template<>
	inline InputInterfaceComponent* AddComponent<InputInterfaceComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(InputInterfaceComponent));
			return nullptr;
		}

		if (UNLIKELY(s_InputInterfaceComponents.Contains(entityId)))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(InputInterfaceComponent), entityId);
			return s_InputInterfaceComponents[entityId];
		}

		InputInterfaceComponent* output = new (ArgusMemorySource::Allocate<InputInterfaceComponent>()) InputInterfaceComponent();
		s_InputInterfaceComponents.Emplace(entityId, output);
		return output;
	}

	template<>
	inline InputInterfaceComponent* GetOrAddComponent<InputInterfaceComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(InputInterfaceComponent));
			return nullptr;
		}

		if (!s_InputInterfaceComponents.Contains(entityId))
		{
			InputInterfaceComponent* output = new (ArgusMemorySource::Allocate<InputInterfaceComponent>()) InputInterfaceComponent();
			s_InputInterfaceComponents.Emplace(entityId, output);
			return output;
		}

		return s_InputInterfaceComponents[entityId];
	}
#pragma endregion
#pragma region ReticleComponent
private:
	static ArgusMap<uint16, ReticleComponent*, ArgusSetAllocator<1> > s_ReticleComponents;
public:
	template<>
	inline ReticleComponent* GetComponent<ReticleComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ReticleComponent));
			return nullptr;
		}

		if (!s_ReticleComponents.Contains(entityId))
		{
			return nullptr;
		}

		return s_ReticleComponents[entityId];
	}

	template<>
	inline ReticleComponent* AddComponent<ReticleComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ReticleComponent));
			return nullptr;
		}

		if (UNLIKELY(s_ReticleComponents.Contains(entityId)))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(ReticleComponent), entityId);
			return s_ReticleComponents[entityId];
		}

		ReticleComponent* output = new (ArgusMemorySource::Allocate<ReticleComponent>()) ReticleComponent();
		s_ReticleComponents.Emplace(entityId, output);
		return output;
	}

	template<>
	inline ReticleComponent* GetOrAddComponent<ReticleComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(ReticleComponent));
			return nullptr;
		}

		if (!s_ReticleComponents.Contains(entityId))
		{
			ReticleComponent* output = new (ArgusMemorySource::Allocate<ReticleComponent>()) ReticleComponent();
			s_ReticleComponents.Emplace(entityId, output);
			return output;
		}

		return s_ReticleComponents[entityId];
	}
#pragma endregion
#pragma region SpatialPartitioningComponent
private:
	static ArgusMap<uint16, SpatialPartitioningComponent*, ArgusSetAllocator<1> > s_SpatialPartitioningComponents;
public:
	template<>
	inline SpatialPartitioningComponent* GetComponent<SpatialPartitioningComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(SpatialPartitioningComponent));
			return nullptr;
		}

		if (!s_SpatialPartitioningComponents.Contains(entityId))
		{
			return nullptr;
		}

		return s_SpatialPartitioningComponents[entityId];
	}

	template<>
	inline SpatialPartitioningComponent* AddComponent<SpatialPartitioningComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(SpatialPartitioningComponent));
			return nullptr;
		}

		if (UNLIKELY(s_SpatialPartitioningComponents.Contains(entityId)))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(SpatialPartitioningComponent), entityId);
			return s_SpatialPartitioningComponents[entityId];
		}

		SpatialPartitioningComponent* output = new (ArgusMemorySource::Allocate<SpatialPartitioningComponent>()) SpatialPartitioningComponent();
		s_SpatialPartitioningComponents.Emplace(entityId, output);
		return output;
	}

	template<>
	inline SpatialPartitioningComponent* GetOrAddComponent<SpatialPartitioningComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(SpatialPartitioningComponent));
			return nullptr;
		}

		if (!s_SpatialPartitioningComponents.Contains(entityId))
		{
			SpatialPartitioningComponent* output = new (ArgusMemorySource::Allocate<SpatialPartitioningComponent>()) SpatialPartitioningComponent();
			s_SpatialPartitioningComponents.Emplace(entityId, output);
			return output;
		}

		return s_SpatialPartitioningComponents[entityId];
	}
#pragma endregion
#pragma region TeamCommanderComponent
private:
	static ArgusMap<uint16, TeamCommanderComponent*, ArgusSetAllocator<1> > s_TeamCommanderComponents;
public:
	template<>
	inline TeamCommanderComponent* GetComponent<TeamCommanderComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when getting %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TeamCommanderComponent));
			return nullptr;
		}

		if (!s_TeamCommanderComponents.Contains(entityId))
		{
			return nullptr;
		}

		return s_TeamCommanderComponents[entityId];
	}

	template<>
	inline TeamCommanderComponent* AddComponent<TeamCommanderComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TeamCommanderComponent));
			return nullptr;
		}

		if (UNLIKELY(s_TeamCommanderComponents.Contains(entityId)))
		{
			ARGUS_LOG(ArgusECSLog, Warning, TEXT("[%s] Attempting to add a %s to entity %d, which already has one."), ARGUS_FUNCNAME, ARGUS_NAMEOF(TeamCommanderComponent), entityId);
			return s_TeamCommanderComponents[entityId];
		}

		TeamCommanderComponent* output = new (ArgusMemorySource::Allocate<TeamCommanderComponent>()) TeamCommanderComponent();
		s_TeamCommanderComponents.Emplace(entityId, output);
		return output;
	}

	template<>
	inline TeamCommanderComponent* GetOrAddComponent<TeamCommanderComponent>(uint16 entityId)
	{
		if (UNLIKELY(entityId >= ArgusECSConstants::k_maxEntities))
		{
			ARGUS_LOG(ArgusECSLog, Error, TEXT("[%s] Invalid entity id %d, used when adding %s."), ARGUS_FUNCNAME, entityId, ARGUS_NAMEOF(TeamCommanderComponent));
			return nullptr;
		}

		if (!s_TeamCommanderComponents.Contains(entityId))
		{
			TeamCommanderComponent* output = new (ArgusMemorySource::Allocate<TeamCommanderComponent>()) TeamCommanderComponent();
			s_TeamCommanderComponents.Emplace(entityId, output);
			return output;
		}

		return s_TeamCommanderComponents[entityId];
	}
#pragma endregion
};
